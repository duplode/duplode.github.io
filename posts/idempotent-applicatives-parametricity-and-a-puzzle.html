<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Idempotent Applicatives, Parametricity, and a Puzzle - The Life Monadic</title>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/pure/0.4.2/pure-min.css" />
        <link rel="stylesheet" type="text/css" href="../css/skin.css" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <!-- Favicon -->
        <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
        <link rel="manifest" href="../site.webmanifest">
        <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
        <meta name="msapplication-TileColor" content="#603cba">
        <meta name="theme-color" content="#f1e7f6">

        <!-- Twitter card -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@duplode" />
        <meta name="twitter:title" content="Idempotent Applicatives, Parametricity, and a Puzzle" />
        
        


    </head>
    <body class="pure-skin-duplode">
      <div class="pure-g-r">
        <div class="pure-u-1-4">
          <div id="navigation" class="no-print">
            <div class="pure-menu pure-menu-open">
              <a class="pure-menu-heading menu-title">
                The Life<br>
                Monadic<br>
                <span class="menu-subtitle">by duplode</span>
              </a>
              <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../posts.html">Posts</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="../rss.xml">RSS</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="pure-u-3-4">
          <div id="content">
            <h1>Idempotent Applicatives, Parametricity, and a Puzzle</h1>

            <p><em>April  1, 2019</em></p>

<div id="contents">
<p class="mini-header">Contents</p>
<ul>
<li><a href="#prolegomena">Prolegomena</a></li>
<li><a href="#drawing-relations">Drawing relations</a></li>
<li><a href="#something-twisted">Something twisted</a></li>
<li><a href="#appendix">Appendix</a>
<ul>
<li><a href="#alternative-presentation-of-the-idempotency-property">Alternative presentation of the idempotency property</a></li>
<li><a href="#alternative-definitions-of-and">Alternative definitions of <code>(&lt;*)</code> and <code>(*&gt;)</code></a></li>
<li><a href="#lawfulness-of-twisted-as-an-applicative-functor">Lawfulness of <code>Twisted</code> as an applicative functor</a></li>
</ul></li>
</ul>
</div>
<p>Some applicative functors are idempotent, in the sense that repeating an effect is the same as having it just once. An example and a counterexample are <code>Maybe</code> and <code>IO</code>, respectively (contrast <code>Just 3 *&gt; Just 3</code> with <code>print 3 *&gt; print 3</code>). More precisely, idempotency means that <code>f &lt;$&gt; u &lt;*&gt; u = (\x -&gt; f x x) &lt;$&gt; u</code>. Given the informal description I began with, though, one might wonder whether the simpler property <code>u *&gt; u = u</code>, which seems to capture the intuition about repeated effects, is equivalent to the usual idempotency property. In this post, I will tell how I went about exploring this conjecture, as well as a few things I learnt about parametricity along the way.</p>
<div>

</div>
<!--more-->
<p>Before I begin, a few remarks about this notion of idempotency. The earliest mention of it that I know of is in <em>Combining Monads</em>, a paper by King and Wadler <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. There, idempotent monads are presented alongside the most widely known concept of commutative monads (<code>f &lt;$&gt; u &lt;*&gt; v = flip f &lt;$&gt; v &lt;*&gt; u</code>). Both properties generalise straightforwardly to applicative functors, which has the neat side-effect of allowing myself to skirt the ambiguity of the phrase “idempotent monad” (in category theory, that usually means a monad that, in Haskell parlance, has a <code>join</code> that is an isomorphism – a meaning that mostly doesn’t show up in Haskell). Lastly, I knew of the conjecture about idempotency amounting to <code>u *&gt; u = u</code> through a Stack Overflow comment by David Feuer, and so I thank him for inspiring this post.</p>
<h2 id="prolegomena">Prolegomena</h2>
<p>Given we are looking into a general claim about applicatives, our first port of call are the applicative laws. Since the laws written in terms of <code>(&lt;*&gt;)</code> can be rather clunky to wield, I will switch to <a href="http://blog.ezyang.com/2012/08/applicative-functors">the monoidal presentation of <code>Applicative</code></a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fzip and unit correspond to (&lt;*&gt;) and pure, respectively.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fzip ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (f a, f b) <span class="ot">-&gt;</span> f (a, b)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fzip (u, v) <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> v</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f ()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>unit <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>Note I am using an uncurried version of <code>fzip</code>, as I feel it makes what follows slightly easier to explain. I will also introduce a couple teensy little combinators so that the required tuple shuffling becomes easier on the eye:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> (a <span class="ot">-&gt;</span> b, a) <span class="ot">-&gt;</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>app (f, x) <span class="ot">=</span> f x</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dup ::</span> a <span class="ot">-&gt;</span> (a, a)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>dup x <span class="ot">=</span> (x, x)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">I will also use the Bifunctor methods for pairs, which amount to:</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">bimap f g (x, y) = (f x, g y)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">first f = bimap f id</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">second g = bimap id g</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span></code></pre></div>
<p>The converse definitions of <code>pure</code> and <code>(&lt;*&gt;)</code> in terms of <code>unit</code> and <code>fzip</code> would be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*&gt;</span> v <span class="ot">=</span> app <span class="op">&lt;$&gt;</span> fzip (u, v)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> x <span class="ot">=</span> <span class="fu">const</span> x <span class="op">&lt;$&gt;</span> unit</span></code></pre></div>
<p>Using that vocabulary, the applicative laws become:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;~&quot; here means &quot;the same up to a relevant isomorphism&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>fzip (u, unit) <span class="op">~</span> u <span class="co">-- up to pairing with ()</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>fzip (unit, u) <span class="op">~</span> u <span class="co">-- up to pairing with ()</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>fzip (fzip (u, v), w) <span class="op">~</span> fzip (u, fzip (v, w)) <span class="co">-- up to reassociating pairs</span></span></code></pre></div>
<p>As for the idempotency property, it can be expressed as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fzip (u, u) <span class="ot">=</span> dup <span class="op">&lt;$&gt;</span> u <span class="co">-- fzip . dup = fmap dup</span></span></code></pre></div>
<p><code>(*&gt;)</code> and its sibling <code>(&lt;*)</code> become:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> fzip (u, v)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, v)</span></code></pre></div>
<p>(Proofs of the claims just above can be found at the appendix at the end of this post.)</p>
<p>Finally, the conjecture amounts to:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, u) <span class="ot">=</span> u <span class="co">-- u *&gt; u = u</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Is equivalent to...</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>fzip (u, u) <span class="ot">=</span> dup <span class="op">&lt;$&gt;</span> u <span class="co">-- idempotency</span></span></code></pre></div>
<p>That <code>fzip (u, u) = dup &lt;$&gt; u</code> implies <code>snd &lt;$&gt; fzip (u, u)</code> is immediate, as <code>snd . dup = id</code>. Our goal, then, is getting <code>fzip (u, u) = dup &lt;$&gt; u</code> out of <code>snd &lt;$&gt; fzip (u, u) = u</code>.</p>
<h2 id="drawing-relations">Drawing relations</h2>
<p>How might we get from <code>snd &lt;$&gt; fzip (u, u) = u</code> to <code>fzip (u, u) = dup &lt;$&gt; u</code>? It appears we have to take a fact about the second components of the pairs in <code>fzip (u, u)</code> (note that mapping <code>snd</code> discards the first components) and squeeze something about the first components out of it (namely, that they are equal to the second components everywhere). At first glance, it doesn’t appear the applicative laws connect the components in any obviously exploitable way. The one glimmer of hope lies in how, in the associativity law…</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fzip (fzip (u, v), w) <span class="op">~</span> fzip (u, fzip (v, w)) <span class="co">-- up to reassociating pairs</span></span></code></pre></div>
<p>… whatever values originally belonging to <code>v</code> must show up as second components of pairs on the left hand side, and as first components on the right hand side. While that, on its own, is too vague to be actionable, there is a seemingly innocuous observation we can make use of: <code>snd &lt;$&gt; fzip (u, u) = u</code> tells us we can turn <code>fzip (u, u)</code> into <code>u</code> using <code>fmap</code> (informally, we can say that they have the same shape), and that they can be <em>related</em> using <code>snd</code> while making use of a free theorem <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. For our current purposes, that means we can borrow the types involved in the left side of the associativity law and use them to draw the following diagram…</p>
<pre><code>                  fzip
(F (a, b), F c) --------&gt; F ((a, b), c)
     |      |                  |     |
     |      |                  |     |
  snd|      |id             snd|     |id 
     |      |                  |     |
     v      v                  v     v
(F   b, F   c ) --------&gt; F (  b,    c)
                  fzip</code></pre>
<p>… such that we get the same result by following either path from the top left corner to the bottom right one. Omitting the occurrences of <code>id</code>, we can state that through this equation:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (first <span class="fu">snd</span>) <span class="op">.</span> fzip <span class="ot">=</span> fzip <span class="op">.</span> first (<span class="fu">fmap</span> <span class="fu">snd</span>)</span></code></pre></div>
<p>In words, it doesn’t matter whether we use <code>snd</code> after or before using <code>fzip</code>. <code>fmap</code> and <code>first</code>, left implicit in the diagram, are used to lift <code>snd</code> across the applicative layer and the pairs, respectively. This is just one specific instance of the free theorem; instead of <code>snd</code> and <code>id</code>, we could have any functions – or, more generally, any relations <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>– between the involved types. Free theorems tell us about relations being preserved; in this case, <code>snd</code> sets up a relation on the left side of the diagram, and <code>fzip</code> preserves it.</p>
<p>We can get back to our problem by slipping in suitable concrete values in the equation. For an arbitrary <code>u :: F A</code>, we have…</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>first <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (fzip (u, u), u) <span class="ot">=</span> fzip (<span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, u), u)</span></code></pre></div>
<p>… and, thanks to our <code>snd &lt;$&gt; fzip (u, u) = u</code> premise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>first <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (fzip (u, u), u) <span class="ot">=</span> fzip (u, u)</span></code></pre></div>
<p>Now, why should we restrict ourselves to the left side of the associativity law? We can get a very similar diagram to work with from the right side:</p>
<pre><code>                  fzip
(F a, F (b, c)) --------&gt; F (a, (b, c))
   |      |                  |    |
   |      |                  |    |
 id|      |snd             id|    |snd
   |      |                  |    |
   v      v                  v    v
(F a, F   c   ) --------&gt; F (a,   c   )
                  fzip</code></pre>
<p>Or, as an equation:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (second <span class="fu">snd</span>) <span class="op">.</span> fzip <span class="ot">=</span> fzip <span class="op">.</span> second (<span class="fu">fmap</span> <span class="fu">snd</span>)</span></code></pre></div>
<p>Proceeding just like before, we get:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>second <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, fzip (u, u)) <span class="ot">=</span> fzip (u, <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, u))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>second <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, fzip (u, u)) <span class="ot">=</span> fzip (u, u)</span></code></pre></div>
<p>Since <code>fzip (u, fzip (u, u)) ~ fzip (fzip (u, u), u)</code> (associativity), we can shuffle that into:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Both first fst and second snd get rid of the value in the middle.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>first <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> fzip (fzip (u, u), u) <span class="ot">=</span> fzip (u, u)</span></code></pre></div>
<p>The equations we squeezed out of the diagrams…</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>first <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (fzip (u, u), u) <span class="ot">=</span> fzip (u, u)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>first <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> fzip (fzip (u, u), u) <span class="ot">=</span> fzip (u, u)</span></code></pre></div>
<p>… can be combined into:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fzip (fzip (u, u), u) <span class="ot">=</span> first dup <span class="op">&lt;$&gt;</span> fzip (u, u)</span></code></pre></div>
<p>This kind of looks like idempotency, except for the extra occurrence of <code>u</code> tagging along for the ride. We might have a go at getting rid of it by sketching a diagram of a slightly different nature, which shows how the relations play out across the specific values that appear in the equation above:</p>
<pre><code>                                        fzip 
          (u, u) :: (F   a   , F a) -----------&gt; F (  a   , a)
                         |       |                    |     |
                         |       |                    |     |
                        R|      S|               {dup}| {id}|
                         |       |                    |     |
                         |       |      fzip          |     |
(fzip (u, u), u) :: (F (a, a), F a) -----------&gt; F ((a, a), a)</code></pre>
<p><code>dup</code> can be used to relate <code>fzip (u, u)</code> and <code>fzip (fzip (u, u), u)</code> on the right of the diagram. That this diagram involves specific values leads to a subtle yet crucial difference from the previous ones: the relation on the right side is not necessarily the function <code>dup</code>, but some relation that happens to agree with <code>dup</code> <em>for the specific values we happen to be using here</em> (that is what I have attempted to suggest by adding the curly brackets as ad hoc notation and dropping the arrow tips from the vertical connectors). This is important because, given how <code>fzip</code> preserves relations, we might be tempted to work backwards and identify <code>R</code> on the left side with <code>dup</code>, giving us a proof – <code>dup &lt;$&gt; u = fzip (u, u)</code> would be an immediate consequence. We can’t do that, though, as <code>R</code> only must agree with <code>dup</code> for those values which show up in a relevant way on the right side. More explicitly, consider some element <code>x :: a</code> of <code>u</code>. If <code>x</code> shows up as a first component anywhere in <code>fzip (u, u)</code>, then the corresponding element of <code>fzip (u, u)</code> must have its first and second components equal to each other (because <code>dup</code> agrees with <code>R</code> on <code>x</code>, and <code>R</code> in turn relates <code>u</code> and <code>fzip (u, u)</code>), and to <code>x</code> (since <code>snd &lt;$&gt; fzip (u, u) = u</code>). If that held for all elements of <code>u</code>, we would have <code>fzip (u, u) = dup &lt;$&gt; u</code>. However if <code>x</code> <em>doesn’t</em> show up as a first component in <code>fzip (u, u)</code>, there are no guarantees (as the right side offers no evidence on what <code>x</code> is related to through <code>R</code>), and so we don’t have grounds for the ultimate claim.</p>
<p>Close, but no cigar.</p>
<h2 id="something-twisted">Something twisted</h2>
<p>While those parametricity tricks gave us no proof, we did learn something interesting: the conjecture holds as long as all elements from <code>u</code> show up as first components in <code>fzip (u, u)</code>. That sounds like a decent lead for a counterexample, so let’s switch course and look for one instead. To begin with, here is an inoffensive length-two vector/homogeneous pair type:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Good</span> a <span class="ot">=</span> <span class="dt">Good</span> a a</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>Here is its <code>Applicative</code> instance, specified in terms of the monoidal presentation:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>unit <span class="ot">=</span> <span class="dt">Good</span> () ()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Good</span> (x1, y1) (x2, y2)</span></code></pre></div>
<p><code>Good</code>, like any other applicative with a single shape, is idempotent – as there is just one shape, it can’t help but be preserved <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. That means we need a second constructor:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Twisted</span> a <span class="ot">=</span> <span class="dt">Evil</span> a a <span class="op">|</span> <span class="dt">Good</span> a a</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p><code>unit</code> can remain the same…</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>unit <span class="ot">=</span> <span class="dt">Good</span> () ()</span></code></pre></div>
<p>… which means the <code>Good</code>-and-<code>Good</code> case <em>must</em> remain the same: the identity effect has to be idempotent <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Good</span> (x1, y1) (x2, y2)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> _</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> _</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> _</span></code></pre></div>
<p>The twist comes in the <code>Evil</code>-and-<code>Evil</code> case: we repeat our pick of a first element of the vector, and thus discard one of the first elements. (We can’t do the same with the second element, as we want <code>snd &lt;$&gt; fzip (u, u) = u</code> to hold.)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Good</span> (x1, y1) (x2, y2)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y1) (x1, y2)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> _</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> _</span></code></pre></div>
<p>The <code>Evil</code>-and-<code>Good</code> case is determined by the right identity law…</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Good</span> (x1, y1) (x2, y2)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y2) (x2, y2)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y1) (x2, y2)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> _</span></code></pre></div>
<p>… while associativity forces our hand in the <code>Good</code>-and-<code>Evil</code> case (consider what would happen in a <code>Good</code>-<code>Evil</code>-<code>Evil</code> chain <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Good</span> (x1, y1) (x2, y2)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y1) (x1, y2)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y1) (x2, y2)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2) <span class="ot">=</span> <span class="dt">Evil</span> (x1, y1) (x1, y2)</span></code></pre></div>
<p><code>Evil</code> spreads, leaving a trail of repeated picks of first elements to the left of its rightmost occurrence in an applicative chain.</p>
<p>Getting an actual <code>Applicative</code> instance from those definitions is easy: fill <code>unit</code> with something, and take away the commas from <code>fzip</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Twisted</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Good</span> x x</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Good</span> x1 x2 <span class="op">&lt;*&gt;</span> <span class="dt">Good</span> y1 y2 <span class="ot">=</span> <span class="dt">Good</span> (x1 y1) (x2 y2)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Evil</span> x1 x2 <span class="op">&lt;*&gt;</span> <span class="dt">Evil</span> y1 y2 <span class="ot">=</span> <span class="dt">Evil</span> (x1 y1) (x1 y2)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Evil</span> x1 x2 <span class="op">&lt;*&gt;</span> <span class="dt">Good</span> y1 y2 <span class="ot">=</span> <span class="dt">Evil</span> (x1 y1) (x2 y2)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Good</span> x1 x2 <span class="op">&lt;*&gt;</span> <span class="dt">Evil</span> y1 y2 <span class="ot">=</span> <span class="dt">Evil</span> (x1 y1) (x1 y2) </span></code></pre></div>
<p>And there it is:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> test <span class="ot">=</span> <span class="dt">Evil</span> <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> test <span class="op">*&gt;</span> test</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> dup <span class="op">&lt;$&gt;</span> test</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (<span class="dv">1</span>,<span class="dv">1</span>) (<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> fzip (test, test)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (<span class="dv">1</span>,<span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> (\x <span class="ot">-&gt;</span> x <span class="op">+</span> x) <span class="op">&lt;$&gt;</span> test</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> <span class="dv">2</span> <span class="dv">4</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">&gt;</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> test <span class="op">&lt;*&gt;</span> test</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> <span class="dv">2</span> <span class="dv">3</span></span></code></pre></div>
<p>The conjecture is thus refuted. While parametricity isn’t truly necessary to bring out this counterexample, I am far from sure I would have thought of it without having explored it under the light of parametricity. On another note, it is rather interesting that there are biased applicatives like <code>Twisted</code>. I wonder whether less contrived cases can be found out there in the wild.</p>
<h2 id="appendix">Appendix</h2>
<p>Below are some derivations that might distract from the main thrust of the post.</p>
<h3 id="alternative-presentation-of-the-idempotency-property">Alternative presentation of the idempotency property</h3>
<p>One direction of the equivalency between the two formulations of the idempotency property follows from a straightforward substitution…</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> u <span class="ot">=</span> (\x <span class="ot">-&gt;</span> f x x) <span class="op">&lt;$&gt;</span> u</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>(,) <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> u <span class="ot">=</span> (\x <span class="ot">-&gt;</span> (,) x x) <span class="op">&lt;$&gt;</span> u</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>fzip (u, u) <span class="ot">=</span> dup <span class="op">&lt;$&gt;</span> u</span></code></pre></div>
<p>… while the other one calls for a small dose of parametricity:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>fzip (u, u) <span class="ot">=</span> dup <span class="op">&lt;$&gt;</span> u</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>first f <span class="op">&lt;$&gt;</span> fzip (u, u) <span class="ot">=</span> first f <span class="op">&lt;$&gt;</span> dup <span class="op">&lt;$&gt;</span> u</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- g &lt;$&gt; f &lt;$&gt; u = g . f &lt;$&gt; u</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>first f <span class="op">&lt;$&gt;</span> fzip (u, u) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> (f x, x)) <span class="op">&lt;$&gt;</span> u</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Parametricity: first f &lt;$&gt; fzip (u, v) = fzip (f &lt;$&gt; u, v)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>fzip (f <span class="op">&lt;$&gt;</span> u, u) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> (f x, x)) <span class="op">&lt;$&gt;</span> u</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>app <span class="op">&lt;$&gt;</span> fzip (f <span class="op">&lt;$&gt;</span> u, u) <span class="ot">=</span> app <span class="op">&lt;$&gt;</span> (\x <span class="ot">-&gt;</span> (f x, x)) <span class="op">&lt;$&gt;</span> u</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> u <span class="ot">=</span> (\x <span class="ot">-&gt;</span> f x x) <span class="op">&lt;$&gt;</span> u</span></code></pre></div>
<h3 id="alternative-definitions-of-and">Alternative definitions of <code>(&lt;*)</code> and <code>(*&gt;)</code></h3>
<p>Starting from…</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> <span class="fu">const</span> <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> v</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">const</span> <span class="op">&lt;$&gt;</span> u <span class="op">&lt;*&gt;</span> v</span></code></pre></div>
<p>… we can switch to the monoidal presentation:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> app <span class="op">&lt;$&gt;</span> fzip (<span class="fu">const</span> <span class="op">&lt;$&gt;</span> u, v)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> app <span class="op">&lt;$&gt;</span> fzip (<span class="fu">flip</span> <span class="fu">const</span> <span class="op">&lt;$&gt;</span> u, v)</span></code></pre></div>
<p>It follows from parametricity that…</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Parametricity: first f &lt;$&gt; fzip (u, v) = fzip (f &lt;$&gt; u, v)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> app <span class="op">.</span> first <span class="fu">const</span> <span class="op">&lt;$&gt;</span> fzip (u, v)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> app <span class="op">.</span> first (<span class="fu">flip</span> <span class="fu">const</span>) <span class="op">&lt;$&gt;</span> fzip (u, v)</span></code></pre></div>
<p>… which amount to…</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> (\(x, y) <span class="ot">-&gt;</span> <span class="fu">const</span> x y) <span class="op">&lt;$&gt;</span> fzip (u, v)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> (\(x, y) <span class="ot">-&gt;</span> <span class="fu">flip</span> <span class="fu">const</span> x y) <span class="op">&lt;$&gt;</span> fzip (u, v)</span></code></pre></div>
<p>… or simply:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*</span> v <span class="ot">=</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> fzip (u, v)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">*&gt;</span> v <span class="ot">=</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> fzip (u, v)</span></code></pre></div>
<h3 id="lawfulness-of-twisted-as-an-applicative-functor">Lawfulness of <code>Twisted</code> as an applicative functor</h3>
<p>Right identity:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>fzip (u, unit) <span class="op">~</span> u</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Case: u = Good x1 x2 </span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> () ()) <span class="co">-- LHS</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Good</span> (x1, ()) (x2, ()) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Note that Twisted behaves like an ordinary length-two vector as</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- long as only Good is involved. That being so, it would have been</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- fine to skip the Good-only cases here and elsewhere.</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Case: u = Evil x1 x2</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> () ()) <span class="co">-- LHS</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, ()) (x2, ()) <span class="co">-- LHS ~ RHS</span></span></code></pre></div>
<p>Left identity:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>fzip (unit, u) <span class="op">~</span> u</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Case: u = Good x1 x2 </span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> () (), <span class="dt">Good</span> y1 y2)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((), y1) ((), y2) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Case: u = Evil x1 x2 </span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> () (), <span class="dt">Evil</span> y1 y2)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((), y1) ((), y2) <span class="co">-- LHS ~ RHS</span></span></code></pre></div>
<p>Associativity:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>fzip (fzip (u, v), w) <span class="op">~</span> fzip (u, fzip (v, w))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Good/Good/Good case: holds.</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2), <span class="dt">Good</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> (x1, y1) (x2, y2), <span class="dt">Good</span> z1, z2)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Good</span> ((x1, y1), z1) ((x2, y2), z2)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, fzip (<span class="dt">Good</span> y1 y2, <span class="dt">Good</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> (y1, z1) (y2, z2))</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Good</span> (x1, (y1, z1)) (x2, (y2, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evil/Evil/Evil case:</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2), <span class="dt">Evil</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> (x1, y1) (x1, y2), <span class="dt">Evil</span> z1, z2)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y1), z2)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, fzip (<span class="dt">Evil</span> y1 y2, <span class="dt">Evil</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y1, z2))</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y1, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Good/Evil/Evil case:</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2), <span class="dt">Evil</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> (x1, y1) (x2, y2), <span class="dt">Evil</span> z1, z2)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y1), z2)</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, fzip (<span class="dt">Evil</span> y1 y2, <span class="dt">Evil</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y1, z2))</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y1, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evil/Good/Evil case:</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2), <span class="dt">Evil</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> (x1, y1) (x2, y2), <span class="dt">Evil</span> z1, z2)</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y1), z2)</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, fzip (<span class="dt">Good</span> y1 y2, <span class="dt">Evil</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y1, z2))</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y1, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evil/Evil/Good case:</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> y1 y2), <span class="dt">Good</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> (x1, y1) (x1, y2), <span class="dt">Good</span> z1, z2)</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y2), z2)</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, fzip (<span class="dt">Evil</span> y1 y2, <span class="dt">Good</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y2, z2))</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y2, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evil/Good/Good case:</span></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> y1 y2), <span class="dt">Good</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> (x1, y1) (x2, y2), <span class="dt">Good</span> z1, z2)</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x2, y2), z2)</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, fzip (<span class="dt">Good</span> y1 y2, <span class="dt">Good</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> x1 x2, <span class="dt">Good</span> (y1, z1) (y2, z2))</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x2, (y2, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a><span class="co">-- Good/Evil/Good case:</span></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> y1 y2), <span class="dt">Good</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Evil</span> (x1, y1) (x1, y2), <span class="dt">Good</span> z1, z2)</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y2), z2)</span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, fzip (<span class="dt">Evil</span> y1 y2, <span class="dt">Good</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y2, z2))</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y2, z2)) <span class="co">-- LHS ~ RHS</span></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a><span class="co">-- Good/Good/Evil case:</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>fzip (fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Good</span> y1 y2), <span class="dt">Evil</span> z1, z2) <span class="co">-- LHS</span></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> (x1, y1) (x2, y2), <span class="dt">Evil</span> z1, z2)</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> ((x1, y1), z1) ((x1, y1), z2)</span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, fzip (<span class="dt">Good</span> y1 y2, <span class="dt">Evil</span> z1 z2)) <span class="co">-- RHS</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>fzip (<span class="dt">Good</span> x1 x2, <span class="dt">Evil</span> (y1, z1) (y1, z2))</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a><span class="dt">Evil</span> (x1, (y1, z1)) (x1, (y1, z2)) <span class="co">-- LHS ~ RHS</span></span></code></pre></div>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>One of <a href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html">Philip Wadler’s papers about monads</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For a gentle initial illustration of the underlying theme of parametricity, see <a href="../posts/what-does-fmap-preserve.html"><em>What Does fmap Preserve?</em></a>. For a more thorough introduction, see <a href="https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free"><em>Parametricity: Money for Nothing and Theorems for Free</em></a>, by Bartosz Milewski.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>A relation is a set of pairs; or, if you will, of associations between values. As an arbitrary example, we can have a less-than relation on integers which includes all pairs of integers <code>(x, y)</code> such that <code>x &lt; y</code>. In particular, functions are relations: seen as a relation, a function <code>f</code> seen in this way includes all pairs <code>(x, f x)</code>, there being exactly one pair for each possible value of the first component.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>One way to prove that is by using parametricity in tandem with the identity laws, analogously to how we used associativity in the previous section, while exploiting how there being only one shape means any applicative value can be related to <code>unit</code>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>See the previous note about relating things to <code>unit</code>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>The appendix includes a proof of the lawfulness of <code>Twisted</code>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div id="comment-nav" class="pure-g-r no-print">
  <div class="pure-u-1-4">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/14">Comment on GitHub</a>

    
  </div>
  <div class="pure-u-1-4">
    
      <a id="reddit-discussion-button" class="pure-button" href="https://reddit.com/https://duplode.github.io/posts/idempotent-applicatives-parametricity-and-a-puzzle.html">Reddit discussion</a>

    
  </div>
  <div class="pure-u-1-4">
    
  </div>
  <div class="pure-u-1-4">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>



          </div>
          <div id="footer" class="no-print">
            <p>Powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
          </div>
        </div>
      </div>
    </body>
</html>
