<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Recent Posts - The Life Monadic</title>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/pure/0.4.2/pure-min.css" />
        <link rel="stylesheet" type="text/css" href="./css/skin.css" />
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/syntax.css" />
    </head>
    <body class="pure-skin-duplode">
      <div class="pure-g-r">
        <div class="pure-u-1-4">
          <div id="navigation" class="no-print">
            <div class="pure-menu pure-menu-open">
              <a class="pure-menu-heading menu-title">
                The Life<br>
                Monadic<br>
                <span class="menu-subtitle">by duplode</span>
              </a>
              <ul>
                <li><a href="./index.html">Home</a></li>
                <li><a href="./posts.html">Posts</a></li>
                <li><a href="./about.html">About</a></li>
                <li><a href="./rss.xml">RSS</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="pure-u-3-4">
          <div id="content">
            <h1>Recent Posts</h1>

            
  <div class="post-teaser">
    <h2>Traversable: A Remix</h2>

    
      <p><code>Traversable</code> is a fun type class. It lies at a crossroad, where many basic Haskell concepts meet, and it can be presented in multiple ways that provide complementary intuitions. In this post, <code>Traversable</code> will be described from a slightly unusual point of view, or at least one that is not put into foreground all that often. We will suspend for a moment the picture of walking across a container while using an effectful function, and instead start by considering what can be done with effectful functions.</p>
<div>

</div>

    

    <p><a href="./posts/traversable-a-remix.html">Read more</a> - May 19, 2017</p>
  </div>

  <div class="post-teaser">
    <h2>What's in a Fold: The Basic Catamorphism in recursion-schemes</h2>

    
      <p>This article is meant as an accessible introduction to the most basic recursion scheme, the catamorphism. It won’t engage in deep dives into theory, or survey practical motives for using recursion schemes – that will be covered by the further reading suggestions at the end. Rather, its main goal is simply offering a concrete presentation of how folds can be generalised. This presentation will be done in terms of the types and combinators used by the <a href="https://hackage.haskell.org/package/recursion-schemes-5.0.1"><em>recursion-schemes</em></a> library, so that the article doubles as an introduction to some of its key conventions.</p>
<div>

</div>

    

    <p><a href="./posts/whats-in-a-fold.html">Read more</a> - March 10, 2017</p>
  </div>

  <div class="post-teaser">
    <h2>Casual Hacking With stack, Reloaded</h2>

    
      <p>It has been quite a while since I <a href="./posts/casual-hacking-with-stack.html">wrote</a> about how to use stack for casual play outside of the context of a conventional Haskell project. In the meantime, stack has gained a feature called the <em>global project</em> which in many cases makes it possible to do quick experiments with essentially no setup, while still taking advantage of the infrastructure provided through stack.</p>
<div>

</div>

    

    <p><a href="./posts/casual-hacking-with-stack-reloaded.html">Read more</a> - February 26, 2017</p>
  </div>

  <div class="post-teaser">
    <h2>Migrating a Project to stack</h2>

    
      <p>This post consists of notes on how I converted one of my Haskell projects to stack. It provides a small illustration of how flexible stack can be in accomodating project organisation quirks on the way towards predictable builds.
    

    <p><a href="./posts/migrating-a-project-to-stack.html">Read more</a> - July 27, 2015</p>
  </div>

  <div class="post-teaser">
    <h2>Applicative Archery</h2>

    
      <p>It is widely agreed that the laws of the <code>Applicative</code> class are not pretty to look at.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">pure</span> <span class="fu">id</span> <span class="fu">&lt;*&gt;</span> v <span class="fu">=</span> v                            <span class="co">-- identity</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">pure</span> f <span class="fu">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="fu">=</span> <span class="fu">pure</span> (f x)               <span class="co">-- homomorphism</span></a>
<a class="sourceLine" id="cb1-3" title="3">u <span class="fu">&lt;*&gt;</span> <span class="fu">pure</span> y <span class="fu">=</span> <span class="fu">pure</span> (<span class="fu">$</span> y) <span class="fu">&lt;*&gt;</span> u              <span class="co">-- interchange</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="fu">pure</span> (<span class="fu">.</span>) <span class="fu">&lt;*&gt;</span> u <span class="fu">&lt;*&gt;</span> v <span class="fu">&lt;*&gt;</span> w <span class="fu">=</span> u <span class="fu">&lt;*&gt;</span> (v <span class="fu">&lt;*&gt;</span> w) <span class="co">-- composition</span></a></code></pre></div>
<p>Monad laws, in comparison, not only look less odd to begin with but can also be stated in a much more elegant way in terms of Kleisli composition <code>(&lt;=&lt;)</code>. Shouldn’t there be an analogous nice presentation for <code>Applicative</code> as well? That became a static question in my mind while I was studying applicative functors many moons ago. After finding surprisingly little commentary on this issue, I decided to try figuring it out by myself. 
    

    <p><a href="./posts/applicative-archery.html">Read more</a> - July  6, 2015</p>
  </div>

  <div class="post-teaser">
    <h2>What Does fmap Preserve?</h2>

    
      <p>A common way of introducing <code>fmap</code> is saying that it only changes the values in a container, and not its structure. Leaving behind the the functors-as-containers metaphor, we can convey the same idea by saying that <code>fmap</code> leaves the context of the values in a <code>Functor</code> unchanged. But what, exactly, is the “context” or “structure” being preserved? “It depends on the functor”, though correct, is not an entirely satisfactory answer. The functor laws, after all, are highly abstract, and make no mention of anything a programmer would be inclined to call “structure” (say, the skeleton of a list); and yet the preservation we alluded to follows from them. After struggling a bit with this question, I realised that the incompatibility is only apparent. This post shows how the tension can be resolved through the mediation of <em>parametricity</em> and <em>naturality</em>, two concepts from different domains that are intertwined in Haskell.</p>
<div>

</div>

    

    <p><a href="./posts/what-does-fmap-preserve.html">Read more</a> - June  2, 2014</p>
  </div>



          </div>
          <div id="footer" class="no-print">
            <p>Powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
          </div>
        </div>
      </div>
    </body>
</html>
