<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Life Monadic</title>
        <link>http://duplode.github.io</link>
        <description><![CDATA[Haskell amusements]]></description>
        <atom:link href="http://duplode.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 27 Jul 2015 06:00:00 UT</lastBuildDate>
        <item>
    <title>Migrating a Project to stack</title>
    <link>http://duplode.github.io/posts/migrating-a-project-to-stack.html</link>
    <description><![CDATA[<p>This post consists of notes on which steps I took to convert convert one of my Haskell projects to stack. It provides a small illustration of how flexible stack can be in accomodating project organisation quirks on the way towards predictable builds.<!--more--> If you want to see the complete results, here are links to the <a href="https://bitbucket.org/duplode/stunts-cartography">Bitbucket repository</a> of Stunts Cartography, the example project I am using, and specifically to the <a href="https://bitbucket.org/duplode/stunts-cartography/src/3eb07c44f6e2eed19591f765b14fc5fbe2b8f946">source tree immediately after the migration</a>.</p>
<p>The first decision to make when migrating a project is which Stackage snapshot to pick. It had been a while since I last updated my project, and building it with the latest versions of all its dependencies would require a few adjustments. That being so, I chose to migrate to stack before any further patches. Since one of the main dependencies was <code>diagrams</code> 1.2, I went for <a href="https://www.stackage.org/lts-2.19"><code>lts-2.19</code></a>, the most recent LTS snapshot with that version of <code>diagrams</code> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<pre><code>$ stack init --resolver lts-2.19</code></pre>
<p><code>cabal init</code> creates a <code>stack.yaml</code> file based on an existing cabal file in the current directory. The <code>--resolver</code> option can be used to pick a specific snapshot.</p>
<p>One complicating factor in the conversion to stack was that two of the extra dependencies, <code>threepenny-gui-0.5.0.0</code> (one major version behind the current one) and <code>zip-conduit</code> wouldn’t build with the LTS snapshot plus current Hackage without version bumps in their cabal files. Fortunately, stack deals very well with situations like this, in which minor changes to some dependency are needed. I simply forked the dependencies on GitHub, pushed the version bumps to my forks and referenced the commits in the <em>remote</em> GitHub repository in <code>stack.yaml</code>. A typical entry for a Git commit in the <code>packages</code> section looks like this:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="kw">-</span> <span class="fu">location:</span>
    <span class="fu">git:</span> https://github.com/duplode/zip-conduit
    <span class="fu">commit:</span> 1eefc8bd91d5f38b760bce1fb8dd16d6e05a671d
  <span class="fu">extra-dep:</span> true</code></pre></div>
<p>Keeping customised dependencies in public remote repositories is an excellent solution. It enables users to build the package without further intervention without requiring developers to clumsily bundle bundle the source tree of the dependencies with the project, or waiting for a pull request to be accepted upstream and reach Hackage.</p>
<p>With the two tricky extra dependencies being offloaded to Git repositories, the next step was using <code>stack solver</code> to figure out the rest of them:</p>
<pre><code>$ stack solver --modify-stack-yaml
This command is not guaranteed to give you a perfect build plan
It's possible that even with the changes generated below, you will still
need to do some manual tweaking
Asking cabal to calculate a build plan, please wait
extra-deps:
- parsec-permutation-0.1.2.0
- websockets-snap-0.9.2.0
Updated /home/duplode/Development/stunts/diagrams/stack.yaml</code></pre>
<p>Here is the final <code>stack.yaml</code>:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">flags:</span>
  <span class="fu">stunts-cartography:</span>
    <span class="fu">repldump2carto:</span> true
<span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">'.'</span>
<span class="kw">-</span> <span class="fu">location:</span>
    <span class="fu">git:</span> https://github.com/duplode/zip-conduit
    <span class="fu">commit:</span> 1eefc8bd91d5f38b760bce1fb8dd16d6e05a671d
  <span class="fu">extra-dep:</span> true
<span class="kw">-</span> <span class="fu">location:</span>
    <span class="fu">git:</span> https://github.com/duplode/threepenny-gui
    <span class="fu">commit:</span> 2dd88e893f09e8e31378f542a9cd253cc009a2c5
  <span class="fu">extra-dep:</span> true
<span class="fu">extra-deps:</span>
<span class="kw">-</span> parsec-permutation-0.1.2.0
<span class="kw">-</span> websockets-snap-0.9.2.0
<span class="fu">resolver:</span> lts-2.19</code></pre></div>
<p><code>repldump2carto</code> is a flag defined in the cabal file. It is used to build a secondary executable. Beyond demonstrating how the <code>flags</code> section of <code>stack.yaml</code> works, I added it because <code>stack ghci</code> expects all possible build targets to have been built <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<p>As I have GHC 7.10.1 from my Linux distribution and the LTS 2.19 snapshot is made for GHC 7.8.4, I needed <code>stack setup</code> as an additional step. That command locally installs (in <code>~/.stack</code>) the GHC version required by the chosen snapshot.</p>
<p>That pretty much concludes the migration. All that is left is demonstrating: <code>stack build</code> to compile the project…</p>
<pre><code>$ stack build
JuicyPixels-3.2.5.2: configure
Boolean-0.2.3: download
# etc. (Note how deps from Git are handled seamlessly.)
threepenny-gui-0.5.0.0: configure
threepenny-gui-0.5.0.0: build
threepenny-gui-0.5.0.0: install
zip-conduit-0.2.2.2: configure
zip-conduit-0.2.2.2: build
zip-conduit-0.2.2.2: install
# etc.
stunts-cartography-0.4.0.3: configure
stunts-cartography-0.4.0.3: build
stunts-cartography-0.4.0.3: install
Completed all 64 actions.</code></pre>
<p>… <code>stack ghci</code> to play with it in GHCi…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
<span class="dt">Configuring</span> <span class="dt">GHCi</span> with the following packages<span class="fu">:</span> stunts<span class="fu">-</span>cartography
<span class="dt">GHCi</span>, version <span class="fl">7.8</span><span class="fu">.</span><span class="dv">4</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help
<span class="dt">Loading</span> package ghc<span class="fu">-</span>prim <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package integer<span class="fu">-</span>gmp <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package base <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="co">-- etc.</span>
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">GameState</span>, <span class="dt">Annotation</span>, <span class="dt">Types.Diagrams</span>, <span class="dt">Pics</span>,
<span class="dt">Pics.MM</span>, <span class="dt">Annotation.Flipbook</span>, <span class="dt">Annotation.LapTrace</span>,
<span class="dt">Annotation.LapTrace.Vec</span>, <span class="dt">Annotation.LapTrace.Parser.Simple</span>,
<span class="dt">Annotation.Parser</span>, <span class="dt">Types.CartoM</span>, <span class="dt">Parameters</span>, <span class="dt">Composition</span>, <span class="dt">Track</span>,
<span class="dt">Util.Misc</span>, <span class="dt">Pics.Palette</span>, <span class="dt">Output</span>, <span class="dt">Util.ByteString</span>, <span class="dt">Util.ZipConduit</span>,
<span class="dt">Replay</span>, <span class="dt">Paths</span>, <span class="dt">Util.Reactive.Threepenny</span>, <span class="dt">Util.Threepenny.Alertify</span>,
<span class="dt">Widgets.BoundedInput</span><span class="fu">.</span>
<span class="fu">*</span><span class="dt">GameState</span><span class="fu">&gt;</span> <span class="fu">:</span>l src<span class="fu">/</span>Viewer.hs <span class="co">-- The Main module.</span>
<span class="co">-- etc.</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>main
<span class="dt">Welcome</span> to <span class="dt">Stunts</span> <span class="dt">Cartography</span><span class="fu">.</span>
<span class="dt">Open</span> your web browser and navigate to localhost<span class="fu">:</span><span class="dv">10000</span> to begin<span class="fu">.</span>

<span class="dt">Listening</span> on http<span class="fu">://</span><span class="fl">127.0</span><span class="fu">.</span><span class="fl">0.1</span><span class="fu">:</span><span class="dv">10000</span><span class="fu">/</span>
[<span class="dv">27</span><span class="fu">/</span><span class="dt">Jul</span><span class="fu">/</span><span class="dv">2015</span><span class="fu">:</span><span class="dv">00</span><span class="fu">:</span><span class="dv">55</span><span class="fu">:</span><span class="dv">11</span> <span class="fu">-</span><span class="dv">0300</span>] Server.httpServe<span class="fu">:</span> <span class="dt">START</span>, binding to
[http<span class="fu">://</span><span class="fl">127.0</span><span class="fu">.</span><span class="fl">0.1</span><span class="fu">:</span><span class="dv">10000</span><span class="fu">/</span>]</code></pre></div>
<p>… and looking at the build output in the depths of <code>.stack-work</code>:</p>
<pre><code>$ .stack-work/dist/x86_64-linux/Cabal-1.18.1.5/build/sc-trk-viewer/sc-trk-viewer
Welcome to Stunts Cartography 0.4.0.3.
Open your web browser and navigate to localhost:10000 to begin.

Listening on http://127.0.0.1:10000/
[26/Jul/2015:20:02:54 -0300] Server.httpServe: START, binding to
[http://127.0.0.1:10000/]</code></pre>
<p>With the upcoming stack 0.2 it will be possible to use <code>stack build --copy-bins --local-bin-path &lt;path&gt;</code> to copy any executables built as part of the project to a path. If the <code>--local-bin-path</code> option is omitted, the default is <code>~/.local/bin</code>. (In fact, you can already copy executables to <code>~/.local/bin</code> with stack 0.1.2 through <code>stack install</code>. However, I don’t want to overemphasise that command, as <code>stack install</code> not being equivalent to <code>cabal install</code> can cause some confusion.)</p>
<p>Hopefully this report will give you an idea of what to expect when migrating your projects to stack. Some details may appear a little strange, given how familiar cabal-install workflows are, and some features are still being shaped. All in all, however, stack works very well already: it definitely makes setting up reliable builds easier. The <a href="https://github.com/commercialhaskell/stack">stack repository at GitHub</a>, and specially <a href="https://github.com/commercialhaskell/stack/wiki">the wiki therein</a>, offers lots of helpful information, in case you need further details and usage tips.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>As a broader point, it just seems polite to, when possible, pick a LTS snapshot over than a nightly for a public project. It is more likely that those interested in building your project already have a specific LTS rather than an arbitrary nightly.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>That being so, a more natural arrangement would be treating <code>repldump2carto</code> as a full-blown subproject by giving it its own cabal file and adding it to the <code>packages</code> section. I would then be able to load only the main project in GHCi with <code>stack ghci stunts-cartography</code>.<a href="#fnref2">↩</a></p></li>
</ol>
</section>

<div id="comment-nav" class="pure-g-r">
  <div class="pure-u-1-5">
    
    
  </div>
  <div class="pure-u-1-5">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/7">Comment on GitHub</a>

    
      
        (see <a href="posts/migrating-a-project-to-stack.html#comment-nav">the full post</a> for a reddit link)
      
    
  </div>
  <div class="pure-u-3-5">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>
]]></description>
    <pubDate>Mon, 27 Jul 2015 06:00:00 UT</pubDate>
    <guid>http://duplode.github.io/posts/migrating-a-project-to-stack.html</guid>
    <dc:creator>Daniel Mlot</dc:creator>
</item>
<item>
    <title>Casual Hacking With stack</title>
    <link>http://duplode.github.io/posts/casual-hacking-with-stack.html</link>
    <description><![CDATA[<p>Sandboxes are exceptionally helpful not just for working in long-term Haskell projects, but also for casual experiments. While playing around, we tend to install all sorts of packages in a carefree way, which increases a lot the risk of entering cabal hell. While vanilla cabal-install sandboxes prevent such a disaster, using them systematically for experiments mean that, unless you are meticulous, you will end up either with dozens of .hs files in a single sandbox or with dozens of copies of the libraries strewn across your home directory. And no one likes to be meticulous while playing around. In that context, stack, the recently released alternative to cabal-install, can prevent trouble with installing packages in a way more manageable than through ad-hoc sandboxes. In this post, I will suggest a few ways of using stack that may be convenient for experiments. I have been using stack for only a few days, therefore suggestions are most welcome!</p>
<div>

</div>
<!--more-->
<p>I won’t dwell on the motivation and philosophy behind stack <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Suffice it to say that, at least in the less exotic workflows, there is a centralised package database somewhere in <code>~/.stack</code> with packages pulled from a <a href="https://www.stackage.org/">Stackage</a> snapshot (and therefore known to be compatible with each other), which is supplemented by a per-project database (that is, just like cabal sandboxes) for packages not in Stackage (from Hackage or anywhere else). As that sounds like a great way to avoid headaches, we will stick to this arrangement, with only minor adjustments.</p>
<p>Once you have installed stack <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, you can create a new environment for experiments with <code>stack new</code>:</p>
<pre><code>$ mkdir -p Development/haskell/playground
$ cd Development/haskell/playground
$ stack new --prefer-nightly</code></pre>
<p>The <code>--prefer-nightly</code> option makes stack use a nightly snapshot of Stackage, as opposed to a long term support one. As we are just playing around, it makes sense to pick as recent as possible packages from the nightly instead of the LTS. (Moreover, I use Arch Linux, which already has GHC 7.10 and <code>base</code> 4.8, while the current LTS snapshot assumes <code>base</code> 4.7.) If this is the first time you use stack, it will pick the latest nightly; otherwise it will default to whatever nightly you already have in <code>~/.stack</code>.</p>
<p><code>stack new</code> creates a neat default project structure for you <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>:</p>
<pre><code>$ ls -R
.:
app  LICENSE  new-template.cabal  Setup.hs  src  stack.yaml  test

./app:
Main.hs

./src:
Lib.hs

./test:
Spec.hs</code></pre>
<p>Of particular interest is the <code>stack.yaml</code> file, which holds the settings for the local stack environment. We will talk more about it soon.</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">flags:</span> <span class="kw">{}</span>
<span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">'.'</span>
<span class="fu">extra-deps:</span> <span class="kw">[]</span>
<span class="fu">resolver:</span> nightly-2015-07-19</code></pre></div>
<p>As for the default <code>new-template.cabal</code> file, you can use its <code>build-depends</code> section to keep track of what you are installing. That will make <code>stack build</code> (the command which builds the current project without installing it) to download and install any dependencies you add to the cabal file automatically. Besides that, having the installed packages noted down may prove useful in case you need to reproduce your configuration elsewhere <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. If your experiments become a real project, you can clean up the <code>build-depends</code> without losing track of the packages you installed for testing purposes by moving their entries to a second cabal file, kept in a subdirectory:</p>
<pre><code>$ mkdir xp
$ cp new-template.cabal xp/xp.cabal
$ cp LICENSE xp # Too lazy to delete the lines from the cabal file.
$ cd xp
$ vi Dummy.hs # module Dummy where &lt;END OF FILE&gt;
$ vi xp.cabal # Adjust accordingly, and list your extra deps.</code></pre>
<p>You also need to tell stack about this fake subproject. All it takes is adding an entry for the subdirectory in <code>stack.yaml</code>:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">'.'</span> <span class="co"># The default entry.</span>
<span class="kw">-</span> <span class="st">'xp'</span></code></pre></div>
<p>With the initial setup done, we use <code>stack build</code> to compile the projects:</p>
<pre><code>$ stack build
new-template-0.1.0.0: configure
new-template-0.1.0.0: build
fmlist-0.9: download
fmlist-0.9: configure
fmlist-0.9: build
new-template-0.1.0.0: install
fmlist-0.9: install
xp-0.1.0.0: configure
xp-0.1.0.0: build
xp-0.1.0.0: install
Completed all 3 actions.</code></pre>
<p>In this test run, I added <code>fmlist</code> as a dependency of the fake package <code>xp</code>, and so it was automatically installed by stack. The output of <code>stack build</code> goes to a <code>.stack-work</code> subdirectory.</p>
<p>With the packages built, we can use GHCi in the stack environment with <code>stack ghci</code>. It loads the library source files of the current project by default:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
<span class="dt">Configuring</span> <span class="dt">GHCi</span> with the following packages<span class="fu">:</span> new<span class="fu">-</span>template, xp
<span class="dt">GHCi</span>, version <span class="fl">7.10</span><span class="fu">.</span><span class="dv">1</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">2</span>] <span class="dt">Compiling</span> <span class="dt">Lib</span>              (
<span class="fu">/</span>home<span class="fu">/</span>duplode<span class="fu">/</span><span class="dt">Development</span><span class="fu">/</span>haskell<span class="fu">/</span>playground<span class="fu">/</span>src<span class="fu">/</span>Lib.hs, interpreted )
[<span class="dv">2</span> <span class="kw">of</span> <span class="dv">2</span>] <span class="dt">Compiling</span> <span class="dt">Dummy</span>            (
<span class="fu">/</span>home<span class="fu">/</span>duplode<span class="fu">/</span><span class="dt">Development</span><span class="fu">/</span>haskell<span class="fu">/</span>playground<span class="fu">/</span>xp<span class="fu">/</span>Dummy.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Dummy</span>, <span class="dt">Lib</span><span class="fu">.</span>
<span class="fu">*</span><span class="dt">Lib</span><span class="fu">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.FMList</span> <span class="kw">as</span> <span class="dt">F</span> <span class="co">-- Which we have just installed.</span>
<span class="fu">*</span><span class="dt">Lib</span> <span class="dt">F</span><span class="fu">&gt;</span> <span class="co">-- We can also load executables specified in the cabal file.</span>
<span class="fu">*</span><span class="dt">Lib</span> <span class="dt">F</span><span class="fu">&gt;</span> <span class="fu">:</span>l <span class="dt">Main</span>
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">2</span>] <span class="dt">Compiling</span> <span class="dt">Lib</span>              (
<span class="fu">/</span>home<span class="fu">/</span>duplode<span class="fu">/</span><span class="dt">Development</span><span class="fu">/</span>haskell<span class="fu">/</span>playground<span class="fu">/</span>src<span class="fu">/</span>Lib.hs, interpreted )
[<span class="dv">2</span> <span class="kw">of</span> <span class="dv">2</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             (
<span class="fu">/</span>home<span class="fu">/</span>duplode<span class="fu">/</span><span class="dt">Development</span><span class="fu">/</span>haskell<span class="fu">/</span>playground<span class="fu">/</span>app<span class="fu">/</span>Main.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Lib</span>, <span class="dt">Main</span><span class="fu">.</span>
<span class="fu">*</span><span class="dt">Main</span> <span class="dt">F</span><span class="fu">&gt;</span></code></pre></div>
<p>Dependencies not in Stackage have to be specified in <code>stack.yaml</code> as well as in the cabal files, so that stack can manage them too. Alternative sources of packages include source trees in subdirectories of the project, Hackage and remote Git repositories <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">flags:</span> <span class="kw">{}</span>
<span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">'.'</span>
<span class="kw">-</span> <span class="st">'xp'</span>
<span class="kw">-</span> <span class="fu">location:</span> deps/acme-missiles-0.3 <span class="co"># Sources in a subdirectory.</span>
  <span class="fu">extra-dep:</span> true <span class="co"># Mark as dep, i.e. not part of the project proper.</span>
<span class="fu">extra-deps:</span>
<span class="kw">-</span> acme-safe-0.1.0.0 <span class="co"># From Hackage.</span>
<span class="kw">-</span> acme-dont-1.1 <span class="co"># Also from Hackage, dependency of acme-safe.</span>
<span class="fu">resolver:</span> nightly-2015-07-19</code></pre></div>
<p><code>stack build</code> will then install the extra dependencies to <code>.stack-work/install</code>. You can use <code>stack solver</code> to chase the indirect dependencies introduced by them. For instance, this is its output after commenting the <code>acme-dont</code> line in the <code>stack.yaml</code> just above:</p>
<pre><code>$ stack solver --no-modify-stack-yaml
This command is not guaranteed to give you a perfect build plan
It's possible that even with the changes generated below, you will still
need to do some manual tweaking
Asking cabal to calculate a build plan, please wait
extra-deps:
- acme-dont-1.1</code></pre>
<p>To conclude this tour, once you get bored of the initial Stackage snapshot all it takes to switch it is changing the <code>resolver</code> field in <code>stack.yaml</code> (with nightlies, that amounts to changing the date at the end of the snapshot name). That will cause all dependencies to be downloaded and built from the chosen snapshot when <code>stack build</code> is next ran. As of now, the previous snapshot will remain in <code>~/.stack</code> unless you go there and delete it manually; however, a command for removing unused snapshots <a href="https://github.com/commercialhaskell/stack/issues/133">is in the plans</a>.</p>
<p>I have not tested the sketch of a workflow presented here extensively, yet what I have seen was enough to convince me stack can provide a pleasant experience for casual experiments as well as full-fledged projects. Happy hacking!</p>
<p><strong>Update:</strong> There is now a follow-up post about the other side of the coin, <a href="../posts/migrating-a-project-to-stack.html">Migrating a Project to stack</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For that, see <a href="https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal">Why is stack not cabal?</a>, written by a member of its development team.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For installation guidance, see the <a href="https://github.com/commercialhaskell/stack/wiki/Downloads">GitHub project wiki</a>. Installing stack is easy, and there are many ways to do it (I simply got it from Hackage with <code>cabal install stack</code>).<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>To create an environment for an existing project, with its own structure and cabal file, you would use <code>stack init</code> instead.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>In any case, you can also use <code>stack exec -- ghc-pkg list</code> to see all packages installed from the snapshot you are currently using. That, however, will be far messier than the <code>build-depends</code> list, as it will include indirect dependencies as well.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>For the latter, see <a href="https://github.com/commercialhaskell/stack/wiki/Nonstandard-project-initialization">the project wiki</a>.<a href="#fnref5">↩</a></p></li>
</ol>
</section>

<div id="comment-nav" class="pure-g-r">
  <div class="pure-u-1-5">
    
    
  </div>
  <div class="pure-u-1-5">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/6">Comment on GitHub</a>

    
      
        (see <a href="posts/casual-hacking-with-stack.html#comment-nav">the full post</a> for a reddit link)
      
    
  </div>
  <div class="pure-u-3-5">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>
]]></description>
    <pubDate>Thu, 23 Jul 2015 02:30:00 UT</pubDate>
    <guid>http://duplode.github.io/posts/casual-hacking-with-stack.html</guid>
    <dc:creator>Daniel Mlot</dc:creator>
</item>
<item>
    <title>Applicative Archery</title>
    <link>http://duplode.github.io/posts/applicative-archery.html</link>
    <description><![CDATA[<p>It is widely agreed that the laws of the <code>Applicative</code> class are not pretty to look at.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure id <span class="fu">&lt;*&gt;</span> v <span class="fu">=</span> v                            <span class="co">-- identity</span>
pure f <span class="fu">&lt;*&gt;</span> pure x <span class="fu">=</span> pure (f x)               <span class="co">-- homomorphism</span>
u <span class="fu">&lt;*&gt;</span> pure y <span class="fu">=</span> pure (<span class="fu">$</span> y) <span class="fu">&lt;*&gt;</span> u              <span class="co">-- interchange</span>
pure (<span class="fu">.</span>) <span class="fu">&lt;*&gt;</span> u <span class="fu">&lt;*&gt;</span> v <span class="fu">&lt;*&gt;</span> w <span class="fu">=</span> u <span class="fu">&lt;*&gt;</span> (v <span class="fu">&lt;*&gt;</span> w) <span class="co">-- composition</span></code></pre></div>
<p>Monad laws, in comparison, not only look less odd to begin with but can also be stated in a much more elegant way in terms of Kleisli composition <code>(&lt;=&lt;)</code>. Shouldn’t there be an analogous nice presentation for <code>Applicative</code> as well? That became a static question in my mind while I was studying applicative functors many moons ago. After finding surprisingly little commentary on this issue, I decided to try figuring it out by myself. <!--more--> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>Let’s cast our eye over <code>Applicative</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> t <span class="ot">=&gt;</span> <span class="dt">Applicative</span> t <span class="kw">where</span>
<span class="ot">    pure  ::</span> a <span class="ot">-&gt;</span> t a
<span class="ot">    (&lt;*&gt;) ::</span> t (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b</code></pre></div>
<p>If our inspiration for reformulating <code>Applicative</code> is Kleisli composition, the only sensible plan is to look for a category in which the <code>t (a -&gt; b)</code> functions-in-a-context from the type of <code>(&lt;*&gt;)</code> are the arrows, just like <code>a -&gt; t b</code> functions are arrows in a Kleisli category. Here is one way to state that plan in Haskell terms:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Applicative</span> t <span class="ot">=&gt;</span> <span class="dt">Starry</span> t <span class="kw">where</span>
<span class="ot">&gt;     idA  ::</span> t (a <span class="ot">-&gt;</span> a)
<span class="ot">&gt;     (.*) ::</span> t (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t (a <span class="ot">-&gt;</span> c)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">.*</span>
<span class="ot">&gt;</span> <span class="co">-- The Applicative constraint is wishful thinking:</span>
<span class="ot">&gt;</span> <span class="co">-- When you wish upon a star...</span></code></pre></div>
<p>The laws of <code>Starry</code> are the category laws for the <code>t (a -&gt; b)</code> arrows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">idA <span class="fu">.*</span> v <span class="fu">=</span> v                <span class="co">-- left identity</span>
u <span class="fu">.*</span> idA <span class="fu">=</span> u                <span class="co">-- right identity</span>
u <span class="fu">.*</span> v <span class="fu">.*</span> w <span class="fu">=</span> u <span class="fu">.*</span> (v <span class="fu">.*</span> w) <span class="co">-- associativity</span></code></pre></div>
<p>The question, then, is whether it is possible to reconstruct <code>Applicative</code> and its laws from <code>Starry</code>. The answer is a resounding yes! The proof is in <a href="../extras/applicative-archery-manuscript.pdf">this manuscript</a>, which I have not transcribed here as it is a little too long for a leisurely post like this one <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. The argument is set in motion by establishing that <code>pure</code> is an arrow mapping of a functor from <strong>Hask</strong> to a <code>Starry</code> category, and that both <code>(&lt;*&gt;)</code> and <code>(.*)</code> are arrow mappings of functors in the opposite direction. That leads to several naturality properties of those functors, from which the <code>Applicative</code> laws can be obtained. Along the way, we also get definitions for the <code>Starry</code> methods in terms of the <code>Applicative</code> ones…</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     idA <span class="fu">=</span> pure id
<span class="ot">&gt;</span>     u <span class="fu">.*</span> v <span class="fu">=</span> fmap (<span class="fu">.</span>) u <span class="fu">&lt;*&gt;</span> v</code></pre></div>
<p>… and vice-versa:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure x <span class="fu">=</span> fmap (const x) idA
u <span class="fu">&lt;*&gt;</span> v <span class="fu">=</span> fmap (<span class="fu">$</span> ()) (u <span class="fu">.*</span> fmap const v)</code></pre></div>
<p>Also interesting is how the property relating <code>fmap</code> and <code>(&lt;*&gt;)</code>…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f u <span class="fu">=</span> pure f <span class="fu">&lt;*&gt;</span> u</code></pre></div>
<p>… now tells us that a <code>Functor</code> results from composing the <code>pure</code> functor with the <code>(&lt;*&gt;)</code> functor. That becomes more transparent if we write it point-free:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap <span class="fu">=</span> (<span class="fu">&lt;*&gt;</span>) <span class="fu">.</span> pure</code></pre></div>
<p>In order to ensure <code>Starry</code> is equivalent to <code>Applicative</code> we still need to prove the converse, that is, obtain the <code>Starry</code> laws from the <code>Applicative</code> laws plus the definitions of <code>idA</code> and <code>(.*)</code> just above. That is not difficult; all it takes is substituting the definitions in the <code>Starry</code> laws and:</p>
<ul>
<li><p>For left identity, noticing that <code>(id .) = id</code>.</p></li>
<li><p>For right identity, applying the interchange law and noticing that <code>($ id) . (.)</code> is <code>id</code> in a better disguise.</p></li>
<li><p>For associativity, using the laws to move all <code>(.)</code> to the left of the <code>(&lt;*&gt;)</code> and then verifying that the resulting messes of dots in both sides are equivalent.</p></li>
</ul>
<p>As a tiny example, here is the <code>Starry</code> instance of <code>Maybe</code>…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Starry</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    idA              <span class="fu">=</span> <span class="dt">Just</span> id
    <span class="dt">Just</span> g <span class="fu">.*</span> <span class="dt">Just</span> f <span class="fu">=</span> <span class="dt">Just</span> (g <span class="fu">.</span> f)
    _      <span class="fu">.*</span> _      <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>… and the verification of the laws for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Left identity:</span>
idA <span class="fu">.*</span> u <span class="fu">=</span> u
<span class="dt">Just</span> id <span class="fu">.*</span> u <span class="fu">=</span> u
<span class="co">-- u = Nothing</span>
<span class="dt">Just</span> id <span class="fu">.*</span> <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="co">-- u = Just f</span>
<span class="dt">Just</span> id <span class="fu">.*</span> <span class="dt">Just</span> f <span class="fu">=</span> <span class="dt">Just</span> f
<span class="dt">Just</span> (id <span class="fu">.</span> f) <span class="fu">=</span> <span class="dt">Just</span> f
<span class="dt">Just</span> f <span class="fu">=</span> <span class="dt">Just</span> f

<span class="co">-- Right identity:</span>
u <span class="fu">.*</span> idA <span class="fu">=</span> u
u <span class="fu">.*</span> <span class="dt">Just</span> id <span class="fu">=</span> u
<span class="co">-- u = Nothing</span>
<span class="dt">Nothing</span> <span class="fu">.*</span> <span class="dt">Just</span> id <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="co">-- u = Just g</span>
<span class="dt">Just</span> g <span class="fu">.*</span> <span class="dt">Just</span> id <span class="fu">=</span> <span class="dt">Just</span> g
<span class="dt">Just</span> (g <span class="fu">.*</span> id) <span class="fu">=</span> <span class="dt">Just</span> g
<span class="dt">Just</span> g <span class="fu">=</span> <span class="dt">Just</span> g

<span class="co">-- Associativity:</span>
u <span class="fu">.*</span> v <span class="fu">.*</span> w <span class="fu">=</span> u <span class="fu">.*</span> (v <span class="fu">.*</span> w)
<span class="co">-- If any of u, v and w are Nothing, both sides will be Nothing.</span>
<span class="dt">Just</span> h <span class="fu">.*</span> <span class="dt">Just</span> g <span class="fu">.*</span> <span class="dt">Just</span> f <span class="fu">=</span> <span class="dt">Just</span> h <span class="fu">.*</span> (<span class="dt">Just</span> g <span class="fu">.*</span> <span class="dt">Just</span> f)
<span class="dt">Just</span> (h <span class="fu">.</span> g) <span class="fu">.*</span> <span class="dt">Just</span> f <span class="fu">=</span> <span class="dt">Just</span> h <span class="fu">.*</span> (<span class="dt">Just</span> (g <span class="fu">.</span> f))
<span class="dt">Just</span> (h <span class="fu">.</span> g <span class="fu">.</span> f) <span class="fu">=</span> <span class="dt">Just</span> (h <span class="fu">.</span> (g <span class="fu">.</span> f))
<span class="dt">Just</span> (h <span class="fu">.</span> g <span class="fu">.</span> f) <span class="fu">=</span> <span class="dt">Just</span> (h <span class="fu">.</span> g <span class="fu">.</span> f)</code></pre></div>
<p>It works just as intended:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="dt">Just</span> (<span class="dv">2</span><span class="fu">*</span>) <span class="fu">.*</span> <span class="dt">Just</span> (subtract <span class="dv">3</span>) <span class="fu">.*</span> <span class="dt">Just</span> (<span class="fu">*</span><span class="dv">4</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">5</span>
<span class="dt">Just</span> <span class="dv">34</span>
<span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="dt">Just</span> (<span class="dv">2</span><span class="fu">*</span>) <span class="fu">.*</span> <span class="dt">Nothing</span> <span class="fu">.*</span> <span class="dt">Just</span> (<span class="fu">*</span><span class="dv">4</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">5</span>
<span class="dt">Nothing</span></code></pre></div>
<p>I do not think there will be many opportunities to use the <code>Starry</code> methods in practice. We are comfortable enough with applicative style, through which we see most <code>t (a -&gt; b)</code> arrows as intermediates generated on demand, rather than truly meaningful values. Furthermore, the <code>Starry</code> laws are not really easier to prove (though they are certainly easier to remember!). Still, it was an interesting exercise to do, and it eases my mind to know that there is a neat presentation of the <code>Applicative</code> laws that I can relate to.</p>
<p>This post is Literate Haskell, in case you wish to play with <code>Starry</code> in GHCi (here is <a href="https://raw.githubusercontent.com/duplode/duplode.github.io/sources/src/posts/applicative-archery.lhs">the raw .lhs file</a> ).</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Starry</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Starry</span> [] <span class="kw">where</span>
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Starry</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Starry</span> <span class="dt">IO</span> <span class="kw">where</span></code></pre></div>
<p>As for proper implementations in libraries, the closest I found was <a href="https://hackage.haskell.org/package/semigroupoids-5.0.0.2/docs/Data-Semigroupoid-Static.html"><code>Data.Semigroupoid.Static</code></a>, which lives in Edward Kmett’s <a href="https://hackage.haskell.org/package/semigroupoids-5.0.0.2"><code>semigroupoids</code></a> package. <em>“Static arrows”</em> is the actual technical term for the <code>t (a -&gt; b)</code> arrows. The module provides…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Static</span> f a b <span class="fu">=</span> <span class="dt">Static</span> {<span class="ot"> runStatic ::</span> f (a <span class="ot">-&gt;</span> b) }</code></pre></div>
<p>… which uses the definitions shown here for <code>idA</code> and <code>(.*)</code> as <code>id</code> and <code>(.)</code> of its <code>Category</code> instance.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is a reasonably well-known alternative formulation of <code>Applicative</code>: the <code>Monoidal</code> class as featured in <a href="http://blog.ezyang.com/2012/08/applicative-functors">this post by Edward Z. Yang</a>. While the laws in this formulation are much easier to grasp, <code>Monoidal</code> feels a little alien from the perspective of a Haskeller, as it shifts the focus from function shuffling to tuple shuffling.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Please excuse some oddities in the manuscript, such as off-kilter terminology and weird conventions (e.g. consistently naming arguments in applicative style as <code>w &lt;*&gt; v &lt;*&gt; u</code> rather than <code>u &lt;*&gt; v &lt;*&gt; w</code> in applicative style). The most baffling choice was using <code>id</code> rather than <code>()</code> as the throwaway argument to <code>const</code>. I guess I did that because <code>($ ())</code> looks bad in handwriting.<a href="#fnref2">↩</a></p></li>
</ol>
</section>

<div id="comment-nav" class="pure-g-r">
  <div class="pure-u-1-5">
    
    
  </div>
  <div class="pure-u-1-5">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/5">Comment on GitHub</a>

    
      
        (see <a href="posts/applicative-archery.html#comment-nav">the full post</a> for a reddit link)
      
    
  </div>
  <div class="pure-u-3-5">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>
]]></description>
    <pubDate>Mon, 06 Jul 2015 20:00:00 UT</pubDate>
    <guid>http://duplode.github.io/posts/applicative-archery.html</guid>
    <dc:creator>Daniel Mlot</dc:creator>
</item>
<item>
    <title>What Does fmap Preserve?</title>
    <link>http://duplode.github.io/posts/what-does-fmap-preserve.html</link>
    <description><![CDATA[<p>A common way of introducing <code>fmap</code> is saying that it only changes the values in a container, and not its structure. Leaving behind the the functors-as-containers metaphor, we can convey the same idea by saying that <code>fmap</code> leaves the context of the values in a <code>Functor</code> unchanged. But what, exactly, is the “context” or “structure” being preserved? “It depends on the functor”, though correct, is not an entirely satisfactory answer. The functor laws, after all, are highly abstract, and make no mention of anything a programmer would be inclined to call “structure” (say, the skeleton of a list); and yet the preservation we alluded to follows from them. After struggling a bit with this question, I realised that the incompatibility is only apparent. This post shows how the tension can be resolved through the mediation of <em>parametricity</em> and <em>naturality</em>, two concepts from different domains that are intertwined in Haskell.</p>
<div>

</div>
<!--more-->
<h2 id="categorical-cautionary-comment">Categorical Cautionary Comment</h2>
<p>A correct, if rather cruel, answer to “Why does <code>fmap</code> preserve structure?” would be “By definition, you silly!” To see what would be meant by that, let’s have a look at the functor laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id <span class="fu">=</span> id                   <span class="co">-- 1st functor law</span>
fmap (g <span class="fu">.</span> f) <span class="fu">=</span> fmap g <span class="fu">.</span> fmap f <span class="co">-- 2nd functor law</span></code></pre></div>
<p><code>fmap</code> is a mapping of functions that takes identity to identity, and composed functions to the corresponding composed functions. Identity and composition make up the structure, in the mathematical sense, of a category. In category theory, a functor is a mapping between categories that preserves category structure. Therefore, the functor laws ensure that Haskell <code>Functor</code>s are indeed functors; more precisely, functors from <strong>Hask</strong> to <strong>Hask</strong>, <strong>Hask</strong> being the category with Haskell types as objects and Haskell functions as arrows.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>That functors preserve category structure is evident. However, our question is not directly about “structure” in the mathematical sense, but with the looser acception it has in programmer parlance. In what follows, our goal will be clarifying this casual meaning.</p>
<h2 id="what-can-you-do-with-a-function">What Can You Do With a Function?</h2>
<p>As an intial, fuzzy characterisation, we can say that, given a functorial value, the <code>Functor</code> context is everything in it other than the wrapped values. Starting from that, a straightforward way of showing why <code>fmap</code> preserves context involves <em>parametric polymorphism</em>; more specifically, the preservation is ensured by the wild generality of the types in the signature of <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class="ot"> ::</span> (<span class="dt">Functor</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (t a <span class="ot">-&gt;</span> t b)</code></pre></div>
<p>We will look at <code>fmap</code> as a function of one argument which converts a plain <code>a -&gt; b</code> function into a function which operates on functorial values. The key fact is that there is very little we can do with the <code>a -&gt; b</code> function when defining <code>fmap</code>. Composition is not an option, as choosing a function other than <code>id</code> to compose it with would require knowledge about the <code>a</code> and <code>b</code> types. The only thing that can be done is applying the function to any <code>a</code> values we can retrieve from the <code>t a</code> functorial value. Since the context of a <code>t a</code> value, whatever it is, does not include the <code>a</code> values, it follows that changes to the context cannot depend on the <code>a -&gt; b</code> function. Given that <code>fmap</code> takes no other arguments, any changes in the context must happen for any <code>a -&gt; b</code> arguments uniformly. The first functor law, however, says that <code>fmap id = id</code>, and so there is one argument, <code>id</code>, which leads to no changes in the context. Therefore, <code>fmap</code> never changes the context.</p>
<p>The informal argument above can be made precise through a proper type theory treatment of parametricity. Philip Wadler’s <em><a href="http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free">Theorems for free!</a></em> is a well-known example of such work. However, a type theory approach, while entirely appropriate, would have us taking concrete Haksell types for granted and only incidentally concluding they are functors; in contrast, our problem begins with functors. For that reason, we will follow a different path and look at the issue from a primarily categorical point of view.</p>
<h2 id="what-is-a-context-after-all">What Is a Context, After All?</h2>
<p>In the spirit of category theory, we will now focus not on the types but on the functions between them. After all, given functional purity any interesting properties of a Haskell value can be verified with suitable functions. Let’s start with a few concrete examples of how the context of a <code>Functor</code> can be probed with functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>The length of a list is perhaps the most obvious example of a structural property. It depends only on the list skeleton, and not at all on the values in it. The type of <code>length</code>, with a fully polymorphic element type which is not mentioned by the result type, reflects such an independence. An obvious consequence is that <code>fmap</code>, which only affects the list elements, cannot change the length of a list. We can state that like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length xs <span class="fu">=</span> length (fmap f xs)</code></pre></div>
<p>Or, in a more categorical fashion:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length <span class="fu">=</span> length <span class="fu">.</span> fmap f</code></pre></div>
<p>Our second example of a structure-probing function will be <code>reverse</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">reverse<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</code></pre></div>
<p>While the result value of <code>reverse</code> obviously depends on the list elements, <code>reverse</code> cannot actually modify the elements, given that the function is fully polymorphic on the element type. <code>fmap</code> applied to a list after reversing it will thus affect the same element values there were before the reversal; they will only have been rearranged. In other words, <code>fmap</code> <em>commutes</em> with <code>reverse</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f <span class="fu">.</span> reverse <span class="fu">=</span> reverse <span class="fu">.</span> fmap f</code></pre></div>
<p>Our final example will be <code>listToMaybe</code> from <code>Data.Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">listToMaybe ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>Operationally, <code>listToMaybe</code> is a safe version of <code>head</code>, which returns <code>Nothing</code> when given an empty list. Again, the function is fully polymorphic in the element type, and so the value of the first element cannot be affected by it. The scenario is very similar to what we have seen for <code>reverse</code>, and an analogous property holds, with the only difference being that <code>fmap</code> is instantiated at a different <code>Functor</code> at each side of the equation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Maybe-fmap on the left, []-fmap on the right.</span>
fmap f <span class="fu">.</span> listToMaybe <span class="fu">=</span> listToMaybe <span class="fu">.</span> fmap f</code></pre></div>
<p>Earlier we said that the <code>Functor</code> context consists of everything but the wrapped values. Our examples illustrate how parametric polymorphism makes it possible to keep that general idea while putting functions rather than values under the spotlight. The context is all that can be probed with functions fully polymorphic on the type parameter of the <code>Functor</code>; or, taking the abstraction further, the context <em>is</em> the collection of functions fully polymorphic on the type parameter of the <code>Functor</code>. We now have done away with the fuzziness of our preliminary, valure-centric definition. The next step is clarifying how that definition relates to <code>fmap</code>.</p>
<h2 id="your-freedom-comes-naturally">Your Freedom Comes Naturally</h2>
<p>By identifying the <code>Functor</code> context with polymorphic functions, we can also state the context-preserving trait of <code>fmap</code> through commutativity equations like those shown in the above examples. For an arbitrary context-probing function <code>r</code>, the equation is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- f is arbitrary, and so are the involved functors.</span>
fmap f <span class="fu">.</span> r <span class="fu">=</span> r <span class="fu">.</span> fmap f</code></pre></div>
<p>The equations for <code>reverse</code> and <code>listToMaybe</code> clearly have that shape. <code>length</code> does not seem to fit at first sight, but that can be easily solved by lifting it to a constant functor such as the one provided by <code>Control.Applicative</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lengthC ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Const</span> <span class="dt">Int</span> a
lengthC <span class="fu">=</span> <span class="dt">Const</span> <span class="fu">.</span> length
<span class="co">-- length = getConst . lengthC</span>

<span class="co">-- For constant functors, fmap f = id regardless of f.</span>
fmap f <span class="fu">.</span> lengthC <span class="fu">=</span> lengthC <span class="fu">.</span> fmap f</code></pre></div>
<p>A similar trick can be done with the <code>Identity</code> functor to make functions in which the type parameter of the <code>Functor</code> appears bare, such as <code>Just :: a -&gt; Maybe a</code>, fit our scheme.</p>
<p>It turns out that there is a category theory concept that captures the commutativity property we are interested in. A <em>natural transformation</em> is a translation between functors which preserves arrows being mapped through them. For Haskell <code>Functor</code>s, that amounts to preserving functions being mapped via <code>fmap</code>. We can display the relation through a diagram:</p>
<figure>
<img src="../images/posts/what-does-fmap-preserve/naturality-diagram.png" alt="Naturality for Haskell Functors. Example instantation: T = []; U = Maybe; r = listToMaybe." /><figcaption><em>Naturality for Haskell <code>Functor</code>s. Example instantation: <code>T = []; U = Maybe; r = listToMaybe</code>.</em></figcaption>
</figure>
<p>The naturality condition matches our commuativity property. Indeed, <em>polymorphic functions are natural transformations between Haskell <code>Functors</code></em>. The proof of this appealing result is not trivial, and requires some theoretical work, just like in the case of the closely related results about parametricity we alluded to earlier. In any case, all it takes to go from “natural transformations preserve <code>fmap</code>” to “<code>fmap</code> preserves natural transformations” is tilting our heads while looking at the diagram above!</p>
<p>Given how we identified <code>Functor</code> contexts, polymorphic functions and natural transformations, we can finally give a precise answer to our question. The context consists of natural transformations between functors, and therefore <code>fmap</code> preserves it.</p>
<h2 id="structures-and-structures">Structures and Structures</h2>
<p>Earlier on, we have said that we would not be directly concerned with structure in the sense mathematicians use the word, but only with the fuzzy Haskell concept that sometimes goes by the same name. To wrap things up, we will now illustrate the fact that both acceptions are not worlds apart. Let’s have another look at the second functor law, which states that <code>fmap</code> preserves composition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap (g <span class="fu">.</span> f) <span class="fu">=</span> fmap g <span class="fu">.</span> fmap f</code></pre></div>
<p>Structure, in the mathematical sense, refers to some collection of interesting operations and distinguished elements. In this example, the relevant operation is function composition, which is part of the structure of the <em>Hask</em> category. Besides that, however, we are now able to note the uncanny resemblance between the shapes of the law, which says that it does not matter whether we compose <code>f</code> and <code>g</code> before applying <code>fmap</code>, and of the commutativity properties we used to characterise functorial contexts. The upshot is that by identifying context and structure of a <code>Functor</code> with polymorphic functions, we retain much of the spirit of the mathematical usage of structure. The interesting operations, in our case, are the polymorphic functions with which the context is probed. Perhaps it even makes sense to keep talking of structure of a <code>Functor</code> even after dropping the container metaphor.</p>
<h2 id="fmap-preserves-fmap">fmap Preserves fmap</h2>
<p>Speaking of the second law, we will, just for kicks, use it to show how to turn things around and look at <code>fmap</code> as a natural transformation between <code>Functor</code>s. In order to do so, we have to recall that <code>(.)</code> is <code>fmap</code> for the function functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- First, we rewrite the second law in a more suggstive form:</span>
fmap (g <span class="fu">.</span> f) <span class="fu">=</span> fmap g <span class="fu">.</span> fmap f
fmap (((<span class="fu">.</span>) g) f) <span class="fu">=</span> (<span class="fu">.</span>) (fmap g) (fmap f)
fmap <span class="fu">.</span> (<span class="fu">.</span>) g <span class="fu">=</span> ((<span class="fu">.</span>) <span class="fu">.</span> fmap) g <span class="fu">.</span> fmap

<span class="co">-- Next, some synonyms to indicate the Functors fmap leads to.</span>

<span class="co">-- fmap from identity to t</span>
<span class="ot">fmap_t ::</span> (<span class="dt">Functor</span> t) <span class="ot">=&gt;</span> (<span class="ot">-&gt;</span>) a b <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t b)
fmap_t <span class="fu">=</span> fmap

<span class="co">-- fmap from identity to ((-&gt;) a)</span>
<span class="ot">fmap_fun ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((<span class="ot">-&gt;</span>) a b <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) a c)
fmap_fun <span class="fu">=</span> (<span class="fu">.</span>)

<span class="co">-- fmap from identity to the composite functor ((-&gt;) a) . t</span>
<span class="ot">fmap_fun_t ::</span> (<span class="dt">Functor</span> t)
           <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((<span class="ot">-&gt;</span>) (t a) (t b) <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t c))
fmap_fun_t <span class="fu">=</span> fmap_fun <span class="fu">.</span> fmap_t

<span class="co">-- The second law then becomes:</span>
fmap_t <span class="fu">.</span> fmap_fun g <span class="fu">=</span> fmap_fun_t g <span class="fu">.</span> fmap_t

<span class="co">-- That, however, shows fmap_t is a natural transformation:</span>
fmap <span class="fu">.</span> fmap g <span class="fu">=</span> fmap g <span class="fu">.</span> fmap</code></pre></div>
<p>By fixing <code>t</code> and <code>a</code> in the signature of <code>fmap_t</code> above, we get one functor on either side of the outer function arrow: <code>((-&gt;) a)</code> on the left and <code>((-&gt;) a) . t</code> on the right. <code>fmap</code> is a natural transformation between these two functors.</p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><p>In <em><a href="http://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/">The Holy Trinity</a></em>, Robert Harper comments on the deep connection between logic, type theory and category theory that allows us to shift seamlessly between the categorical and the type theoretical perspectives, as we have done here.</p></li>
<li><p><em><a href="http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html">You Could Have Defined Natural Transformations</a></em> by Dan Piponi is a very clear introduction to natural transformations in a Haskell context.</p></li>
<li><p>We have already mentioned Philip Wadler’s <em><a href="http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free">Theorems for free!</a></em>, which is a reasonably accessible introduction to the <em>free theorems</em>. <em>Free theorems</em> are results about functions that, thanks to parametric polymorphism, can be deduced from the type of the function alone. Given suitable generalisations, free theorems and naturality conditions provide two parallel ways of reaching the same results about Haskell functions.</p></li>
<li><p><em><a href="http://www.iai.uni-bonn.de/~jv/Voi09b.html">Free Theorems Involving Type Constructor Classes</a></em>, a functional pearl by Janis Voigtländer illustrates how free theorem generation can be generalised to types parametric on type constructors and type classes.</p></li>
<li><p>For an explicitly categorical perspective on parametricity, a good place to start if you are willing to dig into theory is the section on parametricity in <em><a href="https://www.site.uottawa.ca/~phil/papers/">Some Aspects of Categories in Computer Science</a></em> by Philip J. Scott.</p></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A category theory primer would be too big a detour for this post. If the category theory concepts I just mentioned are new to you, I suggest the following gentle introductions for Haskellers, which have very different approaches: <a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell Wikibook chapter on category theory</a>, and Gabriel Gonzalez’s posts <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The category design pattern</a> and <a href="http://www.haskellforall.com/2012/09/the-functor-design-pattern.html">The functor design pattern</a>.<a href="#fnref1">↩</a></p></li>
</ol>
</section>

<div id="comment-nav" class="pure-g-r">
  <div class="pure-u-1-5">
    
    
  </div>
  <div class="pure-u-1-5">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/2">Comment on GitHub</a>

    
      
        (see <a href="posts/what-does-fmap-preserve.html#comment-nav">the full post</a> for a reddit link)
      
    
  </div>
  <div class="pure-u-3-5">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>
]]></description>
    <pubDate>Mon, 02 Jun 2014 06:00:00 UT</pubDate>
    <guid>http://duplode.github.io/posts/what-does-fmap-preserve.html</guid>
    <dc:creator>Daniel Mlot</dc:creator>
</item>
<item>
    <title>Lenses You Can Make at Home</title>
    <link>http://duplode.github.io/posts/lenses-you-can-make-at-home.html</link>
    <description><![CDATA[<p>The most striking traits of the <code>lens</code> library are its astonishing breadth and generality. And yet, the whole edifice is built around van Laarhoven lenses, which are a simple and elegant concept. In this hands-on exposition, I will show how the <code>Lens</code> type can be understood without prerequisites other than a passing acquaintance with Haskell functors. Encouraging sound intuition in an accessible manner can go a long way towards making <code>lens</code> and lenses less intimidating.</p>
<div>

</div>
<!--more-->
<h2 id="humble-beginnings">Humble Beginnings</h2>
<p>Dramatis personæ:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>(..))
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Applicative</span> (<span class="dt">Const</span>(..))</code></pre></div>
<p>I will define a toy data type so that we have something concrete to play with, as well as a starting point for working out generalisations.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span> {<span class="ot"> bar ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>The record definition gets us a function for accessing the <code>bar</code> field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="fu">:</span>t bar
<span class="ot">bar ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>As for the setter, we have to define it ourselves, unless we feel like mucking around with record update syntax.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; setBar ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> setBar x y <span class="fu">=</span> x { bar <span class="fu">=</span> y }</code></pre></div>
<p>Armed with a proper getter and setter pair, we can easily flip the sign of the <code>bar</code> inside a <code>Foo</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dt">Foo</span> <span class="dv">3</span>
<span class="dt">GHCi</span><span class="fu">&gt;</span> setBar x (negate <span class="fu">$</span> bar x)
<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="fu">-</span><span class="dv">3</span>}</code></pre></div>
<p>We can make it even easier by defining a modifier function for <code>bar</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyBar ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> modifyBar k x <span class="fu">=</span> setBar x <span class="fu">.</span> k <span class="fu">.</span> bar <span class="fu">$</span> x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> modifyBar negate x
<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="fu">-</span><span class="dv">3</span>}</code></pre></div>
<p><code>setBar</code> can be recovered from <code>modifyBar</code> by using <code>const</code> to discard the original value and put the new one in its place.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const y <span class="fu">=</span> \_ <span class="ot">-&gt;</span> y</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; setBar' ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> setBar' x y <span class="fu">=</span> modifyBar (const y) x</code></pre></div>
<p>If our data type had several fields, defining a modifier for each of them would amount to quite a lot of boilerplate. We could minimise it by, starting from our <code>modifyBar</code> definition, abstracting from the specific getter and setter for <code>bar</code>. Here, things begin to pick up steam. I will define a general <code>modify</code> function, which, given an appropriate getter-setter pair, can deal with any field of any data type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modify ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
<span class="ot">&gt;</span> modify getter setter k x <span class="fu">=</span> setter x <span class="fu">.</span> k <span class="fu">.</span> getter <span class="fu">$</span> x</code></pre></div>
<p>It is trivial to recover <code>modifyBar</code>; when we do so, <code>s</code> becomes <code>Foo</code> and <code>a</code> becomes <code>Int</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyBar' ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> modifyBar' <span class="fu">=</span> modify bar setBar</code></pre></div>
<h2 id="functors-galore">Functors Galore</h2>
<p>The next step of generalisation is the one leap of faith I will ask of you in the way towards lenses. I will introduce a variant of <code>modify</code> in which the modifying function, rather than being a plain <code>a -&gt; a</code> function, returns a functorial value. Defining it only takes an extra <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s)
<span class="ot">&gt;</span>                      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f s
<span class="ot">&gt;</span> modifyF getter setter k x <span class="fu">=</span> fmap (setter x) <span class="fu">.</span> k <span class="fu">.</span> getter <span class="fu">$</span> x</code></pre></div>
<p>And here is its specialisation for <code>bar</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyBarF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> f <span class="dt">Foo</span>
<span class="ot">&gt;</span> modifyBarF <span class="fu">=</span> modifyF bar setBar</code></pre></div>
<p>Why on Earth we would want to do that? For one, it allows for some nifty tricks depending on the functor we choose. Let’s try it with lists. Specialising the <code>modifyF</code> type would give:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyL ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [s]</code></pre></div>
<p>Providing the getter and the setter would result in a <code>(a -&gt; [a]) -&gt; s -&gt; [s]</code> function. Can you guess what it would do?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> modifyBarF (\y <span class="ot">-&gt;</span> [<span class="dv">0</span><span class="fu">..</span>y]) x
[<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="dv">0</span>},<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="dv">1</span>},<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="dv">2</span>},<span class="dt">Foo</span> {bar <span class="fu">=</span> <span class="dv">3</span>}]</code></pre></div>
<p>As the types suggest, we get a function which modifies the field in multiple ways and collects the results.</p>
<p>I claimed that moving from <code>modify</code> to <code>modifyF</code> was a generalisation. Indeed, we can recover <code>modify</code> by bringing <code>Identity</code>, the dummy functor, into play.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
    fmap f (<span class="dt">Identity</span> x) <span class="fu">=</span> <span class="dt">Identity</span> (f x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyI ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modify' ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
<span class="ot">&gt;</span> modify' getter setter k <span class="fu">=</span>
<span class="ot">&gt;</span>     runIdentity <span class="fu">.</span> modifyF getter setter (<span class="dt">Identity</span> <span class="fu">.</span> k)</code></pre></div>
<p>We wrap the field value with <code>Identity</code> value after applying <code>k</code> and unwrap the final result after applying the setter. Since <code>Identity</code> does nothing interesting to the wrapped values, the overall result boils down to our original <code>modify</code>. If you have found this definition confusing, I suggest that you, as an exercise, rewrite it in pointful style and substitute the definition of <code>modifyF</code>.</p>
<p>We managed to get <code>modify</code> back with little trouble, which is rather interesting. However, what is truly surprising is that we can reconstruct not only the modifier but also the getter! To pull that off, we will use <code>Const</code>, which is a very quaint functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Const</span> a b <span class="fu">=</span> <span class="dt">Const</span> {<span class="ot"> getConst ::</span> a }

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> a) <span class="kw">where</span>
    fmap _ (<span class="dt">Const</span> y) <span class="fu">=</span> <span class="dt">Const</span> y</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyC ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> r a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> r s</code></pre></div>
<p>If functors were really containers, <code>Const</code> would be an Acme product. A <code>Const a b</code> value does not contain anything of type <code>b</code>; what it does contain is an <code>a</code> value that we cannot even modify, given that <code>fmap f</code> is <code>id</code> regardless of what <code>f</code> is. As a consequence, if, given a field of type <code>a</code>, we pick <code>Const a a</code> as the functor to use with <code>modifyF</code>, if our chosen modifying function wraps the field value with <code>Const</code> then it will not be affected by the setter, and we will be able to recover it later. That suffices for recovering the getter.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; get ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> get getter setter <span class="fu">=</span> getConst <span class="fu">.</span> modifyF getter setter <span class="dt">Const</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; getBar ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> getBar <span class="fu">=</span> get bar setBar</code></pre></div>
<h2 id="the-grand-unification">The Grand Unification</h2>
<p>Given a getter and a setter, <code>modifyF</code> gets us a corresponding functorial modifier. From it, by choosing the appropriate functors, we can recover the getter and a plain modifier; the latter, in turn, allows us to recover the setter. We can highlight the correspondence by redefining once more the recovered getters and modifiers, this time in terms of the functorial modifier.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s)
                     <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f s)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modify'' ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
<span class="ot">&gt;</span> modify'' modifier k <span class="fu">=</span> runIdentity <span class="fu">.</span> modifier (<span class="dt">Identity</span> <span class="fu">.</span> k)
<span class="ot">&gt;</span> 
<span class="ot">&gt; modifyBar'' ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> modifyBar'' <span class="fu">=</span> modify'' modifyBarF
<span class="ot">&gt;</span> 
<span class="ot">&gt; set ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s
<span class="ot">&gt;</span> set modifier x y <span class="fu">=</span> modify'' modifier (const y) x
<span class="ot">&gt;</span> 
<span class="ot">&gt; setBar'' ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
<span class="ot">&gt;</span> setBar'' <span class="fu">=</span> set modifyBarF
<span class="ot">&gt;</span> 
<span class="ot">&gt; get' ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> a a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a)
<span class="ot">&gt;</span> get' modifier <span class="fu">=</span> getConst <span class="fu">.</span> modifier <span class="dt">Const</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; getBar' ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> getBar' <span class="fu">=</span> get' modifyBarF</code></pre></div>
<p>The bottom line is that given <code>modifyBarF</code> we can get by without <code>modifyBar</code>, <code>setBar</code> and <code>bar</code>, as <code>modify''</code>, <code>set</code> and <code>get'</code> allow us to reconstruct them whenever necessary. While our first version of <code>get</code> was, in effect, just a specialised <code>const</code> with a wacky implementation, <code>get'</code> is genuinely useful because it cuts the number of separate field manipulation functions we have to deal with by a third.</p>
<h2 id="expanding-horizons">Expanding Horizons</h2>
<p>Even after all of the work so far we can still generalise further! Let’s have a second look at <code>modifyF</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s)
                     <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f s
modifyF getter setter k x <span class="fu">=</span> fmap (setter x) <span class="fu">.</span> k <span class="fu">.</span> getter <span class="fu">$</span> x</code></pre></div>
<p>The type of <code>setter</code> is <code>(s -&gt; a -&gt; s)</code>; however, nothing in the implementation forces the first argument and the result to have the same type. Furthermore, with a different signature <code>k</code> could have a more general type, <code>(a -&gt; f b)</code>, as long as the type of <code>setter</code> was adjusted accordingly. We can thus give <code>modifyF</code> a more general type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyGenF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t)
<span class="ot">&gt;</span>                         <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t
<span class="ot">&gt;</span> modifyGenF getter setter k x <span class="fu">=</span> fmap (setter x) <span class="fu">.</span> k <span class="fu">.</span> getter <span class="fu">$</span> x</code></pre></div>
<p>For the sake of completeness, here are the generalised recovery functions. <code>get</code> is not included because the generalisation does not affect it.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; modifyGen ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t
<span class="ot">&gt;</span> modifyGen modifier k <span class="fu">=</span> runIdentity <span class="fu">.</span> modifier (<span class="dt">Identity</span> <span class="fu">.</span> k)
<span class="ot">&gt;</span> 
<span class="ot">&gt; setGen ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t
<span class="ot">&gt;</span> setGen modifier x y <span class="fu">=</span> modifyGen modifier (const y) x</code></pre></div>
<p>By now, it is clear that our getters and setters need not be ways to manipulate fields in a record. In a broader sense, a getter is anything that produces a value from another; in other words, any function can be a getter. By the same token, any binary function can be a setter, as all that is required is that it combines one value with another producing a third; the initial and final values do not even need to have the same type.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> That is a long way from the toy data type we started with!</p>
<h2 id="the-reveal">The Reveal</h2>
<p>If we look at <code>modifyGenF</code> as a function of two arguments, its result type becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</code></pre></div>
<p>Now, let’s take a peek at <a href="http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Lens.html#t:Lens">Control.Lens.Lens</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Lens</span> s t a b <span class="fu">=</span> forall f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</code></pre></div>
<p>It is the same type! We have reached our destination.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> A lens is what we might have called a generalised functorial modifier; furthermore, sans implementation details we have that:</p>
<ul>
<li>The <code>lens</code> function is <code>modifyGenF</code>;</li>
<li><code>modifyF</code> is <code>lens</code> specialised to produce simple lenses;<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></li>
<li><code>modifyBarF</code> is a lens with type <code>Lens Foo Foo Int Int</code>;</li>
<li><code>(^.)</code> is flipped <code>get'</code>;</li>
<li><code>set</code> is <code>setGen</code>;</li>
<li><code>over</code> is <code>modifyGen</code> further generalised.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></li>
</ul>
<p><code>lens</code> uses type synonyms liberally, so those correspondences are not immediately obvious form the signatures in the documentation. Digging a little deeper, however, shows that in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">ASetter</span> s t a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</code></pre></div>
<p><code>ASetter</code> is merely</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ASetter</span> s t a b <span class="fu">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t</code></pre></div>
<p>Analogously, we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(^.) ::</span> s <span class="ot">-&gt;</span> <span class="dt">Getting</span> a s a <span class="ot">-&gt;</span> a

<span class="kw">type</span> <span class="dt">Getting</span> r s a <span class="fu">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> r a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> r s</code></pre></div>
<p>Behind the plethora of type synonyms - <code>ASetter</code>, <code>Getting</code>, <code>Fold</code>, <code>Traversal</code>, <code>Prism</code>, <code>Iso</code> and so forth - there are different choices of functors,<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> which make it possible to capture many different concepts as variations on lenses. The variations may be more general or less general than lenses; occasionally they are neither, as the overlap is just partial. The fact that we can express so much through parametrization of functors is key to the extraordinary breadth of <code>lens</code>.</p>
<h2 id="going-forward">Going Forward</h2>
<p>This exposition is primarily concerned with building lenses, and so very little was said about how to use them. In any case, we have seen enough to understand why lenses are also known as functional references. By unifying getters and setters, lenses provide a completely general vocabulary to point at parts of a whole.</p>
<p>Finally, a few words about composition of lenses are unavoidable. One of the great things about lenses is that they are just functions; even better, they are functions with signatures tidy enough for them to compose cleanly with <code>(.)</code>. That makes it possible to compose lenses independently of whether you intend to get, set or modify their targets. Here is a quick demonstration using the tuple lenses from <code>lens</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="fu">:</span>m
<span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="fu">:</span>m <span class="fu">+</span><span class="dt">Control.Lens</span>
<span class="dt">GHCi</span><span class="fu">&gt;</span> ((<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>)) <span class="fu">^.</span> _1 <span class="fu">.</span> _2
<span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="dv">2</span>
<span class="dt">GHCi</span><span class="fu">&gt;</span> set (_1 <span class="fu">.</span> _2) <span class="dv">0</span> ((<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>))
<span class="dt">GHCi</span><span class="fu">&gt;</span> ((<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">4</span>))</code></pre></div>
<p>A perennial topic in discussions about <code>lens</code> is the order of composition of lenses. They are often said to compose backwards; that is, backwards with respect to composition of record accessors and similar getters. For instance, the getter corresponding to the <code>_1 . _2</code> lens is <code>snd . fst</code>. The claim that lenses compose backwards, or in the “wrong order”, however, are only defensible when talking about style, and not about semantics. That becomes clear after placing the signatures of a getter and its corresponding lens side by side.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="fu">:</span>t fst
fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a
<span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="fu">:</span>t _1<span class="ot"> ::</span> <span class="dt">Lens'</span> (a, b) a
_1<span class="ot"> ::</span> <span class="dt">Lens'</span> (a, b) a
<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> f (a, b)</code></pre></div>
<p>The getter takes a value of the source type and produces a value of the target type. The lens, however, takes a function from the target type and produces a function from the source type. Therefore, it is no surprise that the order of composition differs, and the order for lenses is entirely natural. That ties in closely to what we have seen while implementing lenses. While we can squeeze lenses until they give back getters, it is much easier to think of them as generalised modifiers.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>We are not quite as free when it comes to pairing getters and setters. Beyond the obvious need for getter and setter to start from values of the same type, they should behave sanely when composed. In particular, the following should hold:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">get' modifier (setGen modifier y x) ≡ y

setGen modifier (get' modifier x) x ≡ x

setGen modifier z (setGen modifier y x) ≡ setGen modifier z x</code></pre></div>
<a href="#fnref1">↩</a></li>
<li id="fn2"><p>“What about the <code>forall</code>?” you might ask. Are we cheating? Not quite. The <code>forall</code> is there to control how <code>f</code> is specialised when lens combinators are used. The underlying issue does not affect our reasoning here. If you are into type system subtleties, there were a few interesting comments about it in the <a href="http://www.reddit.com/r/haskell/comments/241aec/lenses_you_can_make_at_home/ch2rbgp">reddit thread</a> for this post.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><code>Lens' s a</code> or <code>Lens s s a a</code>, as opposed to <code>Lens s t a b</code>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Yes, even further; from taking modifying functions to taking modifying <a href="https://www.fpcomplete.com/user/liyang/profunctors">profunctors</a>. The difference need not worry us now.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>And in some cases of profunctors to replace the function type constructor.<a href="#fnref5">↩</a></p></li>
</ol>
</section>

<div id="comment-nav" class="pure-g-r">
  <div class="pure-u-1-5">
    
    
  </div>
  <div class="pure-u-1-5">
    <a id="gh-comments-button" class="pure-button" href="https://github.com/duplode/duplode.github.io/issues/1">Comment on GitHub</a>

    
      
        (see <a href="posts/lenses-you-can-make-at-home.html#comment-nav">the full post</a> for a reddit link)
      
    
  </div>
  <div class="pure-u-3-5">
  </div>
</div>

<div><div class="license">
  <p>
    <span class="inline-centered">
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </span>
    <span class="inline-centered">
      Post licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </span>
  </p>
</div>

</div>
]]></description>
    <pubDate>Sat, 26 Apr 2014 12:00:00 UT</pubDate>
    <guid>http://duplode.github.io/posts/lenses-you-can-make-at-home.html</guid>
    <dc:creator>Daniel Mlot</dc:creator>
</item>

    </channel>
</rss>
